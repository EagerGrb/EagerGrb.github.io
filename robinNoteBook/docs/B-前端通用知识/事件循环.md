# 事件循环（Event Loop）详解

## 引入
事件循环是浏览器的核心概念，与计时器、Promise、Ajax、Node.js等技术密切相关。要理解事件循环，我们需要先了解进程与线程的概念。

## 一、浏览器的进程模型

### 1.1 进程（Process）是什么
- 进程是程序运行时的实例，是操作系统资源分配和调度的独立单位
- 每个进程有自己独立的内存空间，可分配CPU时间、文件、消息队列等资源
- 进程可创建子进程，形成树状结构
- 简单理解：程序运行所需的专属内存空间就是进程
- 每个应用至少有一个进程，不同进程间相互独立，需双方同意才能通信

### 1.2 线程（Thread）是什么
- 线程是程序执行的基本单位，是单一顺序控制流程
- 一个进程可包含多个线程，它们共享进程资源（内存空间），但有自己的线程栈和程序计数器
- 简单理解：线程是进程的执行者
- 进程启动时会创建一个主线程来运行代码
- 多个线程间资源共享、通信简单、独立执行、开销较小

### 1.3 进程与线程的关系与区别
- 进程是程序运行实例，每个程序至少需要一个进程（多进程可提高稳定性）
- 线程是进程的执行者，每个进程至少有一个主线程
- 线程是操作系统调度的最小单位，同一进程内的线程共享资源
- 创建线程比创建进程开销小，因为线程可复用进程资源
- 线程间通信比进程间通信简单

## 二、浏览器的进程和线程
浏览器是多进程多线程应用程序。

### 2.1 浏览器的主要进程
浏览器启动时会自动启动多个进程，主要包括：

1. **浏览器进程**
   - 负责界面显示、用户交互、子进程管理
   - 内部启动多个线程处理不同任务

2. **网络进程**
   - 负责加载网络资源
   - 内部启动多个线程处理不同网络任务

3. **渲染进程**
   - 启动后开启渲染主线程，负责执行HTML、CSS、JS代码
   - 默认每个标签页一个渲染进程，保证互不影响

### 2.2 渲染主线程的工作原理
渲染主线程是浏览器最繁忙的线程，需处理：解析HTML/CSS、计算样式、布局、处理图层、渲染画面（60次/秒）、执行JS代码、执行事件处理函数、执行计时器回调等。

为有序处理这些任务，渲染主线程使用**消息队列**机制：

- 渲染主线程进入无限循环
- 每次循环检查消息队列是否有任务，有则取出第一个执行，无则休眠
- 其他线程可随时向消息队列添加任务（添加到队列末尾）
- 添加新任务时，如主线程休眠则将其唤醒继续循环

消息队列是渲染主线程的任务管家，确保任务有序、持续地执行。

## 三、事件循环

### 3.1 事件循环的定义
事件循环（又称消息循环、Run Loop）是渲染主线程不断从消息队列中读取事件并执行的过程。

- 是浏览器渲染主线程的工作方式
- 并非只有渲染主线程有事件循环（网络线程有时也有）
- 不是所有线程都有事件循环，但渲染主线程通常都有

### 3.2 任务优先级机制
任务本身无优先级，但消息队列有优先级，通常分为三类：

**优先级顺序：微队列 > 交互队列 > 延时队列**

- **微队列**：存放需最快执行的任务（如Promise和MutationObserver产生的任务）
- **交互队列**：存放用户操作产生的事件处理任务
- **延时队列**：存放计时器到达后的回调任务

执行规则：高优先级队列会"插队"，同一队列内遵循先进先出原则。微队列完全空了才会执行交互队列任务，依此类推。

### 3.3 执行示例解析

#### 示例一
```javascript
setTimeout(function () {
  console.log(1);
}, 0);

function delay(duration) {
  var start = Date.now();
  while (Date.now() - start < duration) {}
}
delay(3000);
console.log(2);
```

**输出顺序**：2 → 1

**解析**：整体作为任务①执行。setTimeout创建任务②放入延时队列（即使计时0秒，也要等任务①完成）。delay阻塞主线程3秒，输出2后任务①完成，再执行任务②输出1。

#### 示例二
```javascript
function a() {
  console.log(1);
  Promise.resolve().then(function () {
    console.log(2);
  });
}
setTimeout(function () {
  console.log(3);
}, 0);

Promise.resolve().then(a);

console.log(5);
```

**输出顺序**：5 → 1 → 2 → 3

**解析**：
1. 整体作为任务①执行
2. setTimeout创建任务②放入延时队列
3. Promise创建任务③（执行a函数）放入微队列
4. 输出5，任务①完成
5. 优先执行微队列任务③：输出1，创建任务④放入微队列，任务③完成
6. 执行新的微队列任务④：输出2，任务④完成
7. 执行延时队列任务②：输出3

#### 练习题
```javascript
function a() {
  console.log(1);
  Promise.resolve().then(function () {
    console.log(2);
  });
}

setTimeout(function () {
  console.log(3);
  Promise.resolve().then(a)
}, 0);

Promise.resolve().then(function(){  
  console.log(4);
});

console.log(5);
```

**输出顺序**：5 → 4 → 3 → 1 → 2

## 四、相关问题解答

### 4.1 为什么需要事件循环
JavaScript是单线程语言（运行在浏览器渲染主线程），同一时间只能执行一个任务。若无事件循环等调度机制，浏览器将无法有序处理并发任务，可能导致页面无响应。

### 4.2 如何理解JavaScript的异步
JavaScript中无法立即处理的任务包括：
- 计时任务（setTimeout、setInterval）
- 网络通信任务（XHR、Fetch）
- 用户交互任务（事件监听）

若主线程等待这些任务完成，会导致阻塞、页面卡死。浏览器采用异步机制解决：

1. 主线程将耗时任务交给其他线程处理
2. 主线程继续执行后续代码
3. 其他线程完成任务后，将回调函数包装成任务加入消息队列尾部
4. 主线程通过事件循环按序执行队列中的任务

简言之：单线程是异步产生的原因，事件循环是异步的主要实现方式。